<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Conway's Game of Life - 4x4 Purple Pixels</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const cellSize = 2;
  let cols, rows, grid;

  // Variables for recording
  const recordedChunks = [];
  let mediaRecorder;
  let isRecording = false;

  // Fixed resolution for video recording
  const recordingWidth = 1920; // Set the resolution (1920x1080)
  const recordingHeight = 1080;

  // Resize canvas when window is resized
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    cols = Math.floor(canvas.width / cellSize);
    rows = Math.floor(canvas.height / cellSize);
    grid = createGrid();
  }

  window.addEventListener('resize', resizeCanvas);

  // Create grid with random state
  function createGrid() {
    const grid = [];
    for (let y = 0; y < rows; y++) {
      const row = [];
      for (let x = 0; x < cols; x++) {
        row.push(Math.random() > 0.8 ? 1 : 0); // Random start
      }
      grid.push(row);
    }
    return grid;
  }

  // Get alive neighbors of a cell
  function getAliveNeighbors(grid, x, y) {
    let count = 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
          count += grid[ny][nx];
        }
      }
    }
    return count;
  }

  // Update grid based on Conway's rules
  function updateGrid(grid) {
    const newGrid = [];
    for (let y = 0; y < rows; y++) {
      const newRow = [];
      for (let x = 0; x < cols; x++) {
        const alive = grid[y][x];
        const neighbors = getAliveNeighbors(grid, x, y);
        if (alive) {
          newRow.push(neighbors === 2 || neighbors === 3 ? 1 : 0);
        } else {
          newRow.push(neighbors === 3 ? 1 : 0);
        }
      }
      newGrid.push(newRow);
    }
    return newGrid;
  }

  // Draw grid on canvas
  function drawGrid(grid) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (grid[y][x]) {
          ctx.fillStyle = 'purple';
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
    }
  }

  // Setup video recording with fixed resolution
  function setupRecording() {
    const stream = canvas.captureStream(30); // Capture the stream at 30 FPS

    // Create a video track with the desired resolution for recording
    const videoTrack = stream.getVideoTracks()[0];
    const capabilities = videoTrack.getCapabilities();
    const constraints = {
      width: recordingWidth, // Set to your desired width (e.g., Full HD)
      height: recordingHeight, // Set to your desired height (e.g., Full HD)
      frameRate: 30,
    };

    // Apply constraints (optional, depending on browser support)
    videoTrack.applyConstraints(constraints);

    mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
    mediaRecorder.ondataavailable = (event) => {
      recordedChunks.push(event.data);
    };
    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'game_of_life.webm';
      link.click();
      URL.revokeObjectURL(url);
    };
  }

  // Start recording
  function startRecording() {
    if (!isRecording) {
      recordedChunks.length = 0;
      mediaRecorder.start();
      isRecording = true;
      console.log('Recording started...');
    }
  }

  // Stop recording
  function stopRecording() {
    if (isRecording) {
      mediaRecorder.stop();
      isRecording = false;
      console.log('Recording stopped...');
    }
  }

  // Resize canvas and start the game
  resizeCanvas();

  // Main animation loop
  function loop() {
    drawGrid(grid);
    grid = updateGrid(grid);
    if (isRecording) {
      startRecording();
    }
    requestAnimationFrame(loop);
  }

  // Event to start and stop recording via keyboard press (for example)
  window.addEventListener('keydown', (event) => {
    if (event.key === 'r') { // Press 'r' to start/stop recording
      if (isRecording) {
        stopRecording();
      } else {
        setupRecording();
        startRecording();
      }
    }
  });

  loop();
</script>
</body>
</html>
